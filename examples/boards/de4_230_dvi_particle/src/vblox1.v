
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
//`define USE_DDR2_DIMM2

module de4_230
  (

   //////// CLOCK //////////
   GCLKIN,
   GCLKOUT_FPGA,
   OSC_50_Bank2,
   OSC_50_Bank3,
   OSC_50_Bank4,
   OSC_50_Bank5,
   OSC_50_Bank6,
   OSC_50_Bank7,
   PLL_CLKIN_p,

   //////// Temperature //////////
   TEMP_INT_n,
   TEMP_SMCLK,
   TEMP_SMDAT,

   //////// Current //////////
   CSENSE_ADC_FO,
   CSENSE_CS_n,
   CSENSE_SCK,
   CSENSE_SDI,
   CSENSE_SDO,

   //////// LED x 8 //////////
   LED,

   //////////// SLIDE SWITCH x 4 //////////
   SLIDE_SW,

   //////// BUTTON x 4 //////////
   BUTTON,
   CPU_RESET_n,

   RUP_PAD,
   RDN_PAD,

`ifndef USE_DDR2_DIMM2
   //////// DDR2 SODIMM //////////
   M1_DDR2_addr,
   M1_DDR2_ba,
   M1_DDR2_cas_n,
   M1_DDR2_cke,
   M1_DDR2_clk,
   M1_DDR2_clk_n,
   M1_DDR2_cs_n,
   M1_DDR2_dm,
   M1_DDR2_dq,
   M1_DDR2_dqs,
   M1_DDR2_dqsn,
   M1_DDR2_odt,
   M1_DDR2_ras_n,
   M1_DDR2_SA,
   M1_DDR2_SCL,
   M1_DDR2_SDA,
   M1_DDR2_we_n,

`else
   //////// DDR2 SODIMM //////////

   M2_DDR2_addr,
   M2_DDR2_ba,
   M2_DDR2_cas_n,
   M2_DDR2_cke,
   M2_DDR2_clk,
   M2_DDR2_clk_n,
   M2_DDR2_cs_n,
   M2_DDR2_dm,
   M2_DDR2_dq,
   M2_DDR2_dqs,
   M2_DDR2_dqsn,
   M2_DDR2_odt,
   M2_DDR2_ras_n,
   M2_DDR2_SA,
   M2_DDR2_SCL,
   M2_DDR2_SDA,
   M2_DDR2_we_n ,
`endif  //USE_DDR2_DIMM2

   //////////// HSMC-A/B, HSMC-A/B connect to DVI - FullHD TX/RX //////////
   DVI_EDID_WP,
   DVI_RX_CLK,
   DVI_RX_CTL,
   DVI_RX_D,
   DVI_RX_DDCSCL,
   DVI_RX_DDCSDA,
   DVI_RX_DE,
   DVI_RX_HS,
   DVI_RX_SCDT,
   DVI_RX_VS,

   DVI_TX_CLK,
   DVI_TX_CTL,
   DVI_TX_D,
   DVI_TX_DDCSCL,
   DVI_TX_DDCSDA,
   DVI_TX_DE,
   DVI_TX_DKEN,
   DVI_TX_HS,
   DVI_TX_HTPLG,
   DVI_TX_ISEL,
   DVI_TX_MSEN,
   DVI_TX_PD_N,
   DVI_TX_SCL,
   DVI_TX_SDA,
   DVI_TX_VS,

   //////////// HSMC I2C //////////
   HSMC_SCL,
   HSMC_SDA
   );

   //=======================================================
   //  PARAMETER declarations
   //=======================================================


   //=======================================================
   //  PORT declarations
   //=======================================================

   //////////// CLOCK //////////
   input                        GCLKIN;
   output                       GCLKOUT_FPGA;
   input                        OSC_50_Bank2;
   input                        OSC_50_Bank3;
   input                        OSC_50_Bank4;
   input                        OSC_50_Bank5;
   input                        OSC_50_Bank6;
   input                        OSC_50_Bank7;
   input                        PLL_CLKIN_p;

   //////////// Temperature //////////
   input                        TEMP_INT_n;
   output                       TEMP_SMCLK;
   inout                        TEMP_SMDAT;

   //////////// Current //////////
   output                       CSENSE_ADC_FO;
   output               [1:0]   CSENSE_CS_n;
   output                       CSENSE_SCK;
   output                       CSENSE_SDI;
   input                        CSENSE_SDO;

   //////////// LED x 8 //////////
   output [7:0]                 LED;

   //////////// SLIDE SWITCH x 4 //////////
   input [3:0]                  SLIDE_SW;

   //////////// BUTTON x 4 //////////
   input [3:0]                  BUTTON;
   input                        CPU_RESET_n;

   input                        RUP_PAD;
   input                        RDN_PAD;

`ifndef USE_DDR2_DIMM2
   //////////// DDR2 SODIMM //////////
   output [15:0]                M1_DDR2_addr;
   output [2:0]                 M1_DDR2_ba;
   output                       M1_DDR2_cas_n;
   output [1:0]                 M1_DDR2_cke;
   inout [1:0]                  M1_DDR2_clk;
   inout [1:0]                  M1_DDR2_clk_n;
   output [1:0]                 M1_DDR2_cs_n;
   output [7:0]                 M1_DDR2_dm;
   inout [63:0]                 M1_DDR2_dq;
   inout [7:0]                  M1_DDR2_dqs;
   inout [7:0]                  M1_DDR2_dqsn;
   output [1:0]                 M1_DDR2_odt;
   output                       M1_DDR2_ras_n;
   output [1:0]                 M1_DDR2_SA;
   output                       M1_DDR2_SCL;
   inout                        M1_DDR2_SDA;
   output                       M1_DDR2_we_n;

`else
   //////////// DDR2 SODIMM //////////
   output [15:0]                M2_DDR2_addr;
   output [2:0]                 M2_DDR2_ba;
   output                       M2_DDR2_cas_n;
   output [1:0]                 M2_DDR2_cke;
   inout [1:0]                  M2_DDR2_clk;
   inout [1:0]                  M2_DDR2_clk_n;
   output [1:0]                 M2_DDR2_cs_n;
   output [7:0]                 M2_DDR2_dm;
   inout [63:0]                 M2_DDR2_dq;
   inout [7:0]                  M2_DDR2_dqs;
   inout [7:0]                  M2_DDR2_dqsn;
   output [1:0]                 M2_DDR2_odt;
   output                       M2_DDR2_ras_n;
   output [1:0]                 M2_DDR2_SA;
   output                       M2_DDR2_SCL;
   inout                        M2_DDR2_SDA;
   output                       M2_DDR2_we_n;

`endif //`ifndef USE_DDR2_DIMM2

   //////////// HSMC-A, HSMC-A connect to DVI - FullHD TX/RX //////////
   output                      DVI_EDID_WP;
   input                       DVI_RX_CLK;
   input            [3:1]      DVI_RX_CTL;
   input           [23:0]      DVI_RX_D;
   inout                       DVI_RX_DDCSCL;
   inout                       DVI_RX_DDCSDA;
   input                       DVI_RX_DE;
   input                       DVI_RX_HS;
   input                       DVI_RX_SCDT;
   input                       DVI_RX_VS;

   output                      DVI_TX_CLK;
   output           [3:1]      DVI_TX_CTL;
   output          [23:0]      DVI_TX_D;
   inout                       DVI_TX_DDCSCL;
   inout                       DVI_TX_DDCSDA;
   output                      DVI_TX_DE;
   output                      DVI_TX_DKEN;
   output                      DVI_TX_HS;
   output                      DVI_TX_HTPLG;
   output                      DVI_TX_ISEL;
   output                      DVI_TX_MSEN;
   output                      DVI_TX_PD_N;
   output                      DVI_TX_SCL;
   inout                       DVI_TX_SDA;
   output                      DVI_TX_VS;

   //////////// HSMC I2C //////////
   output                      HSMC_SCL;
   inout                       HSMC_SDA;

   //=======================================================
   //  REG/WIRE declarations
   //=======================================================

   // wire dvi_rx_clk_inverted;
/* -----\/----- EXCLUDED -----\/-----
   reg [23:0] sampled_DVI_RX_D;
   reg        sampled_DVI_RX_DE;
   reg        sampled_DVI_RX_HS;
   reg        sampled_DVI_RX_VS;
 -----/\----- EXCLUDED -----/\----- */

   wire dvi_tx_clk_wire;
   wire dvi_tx_underflow;

   wire [7:0] led_wire;

   wire ddr_pll_locked;
   wire ddr_pll_mem_clk;

   wire ddr_init_done;
   wire ddr_cal_success;
   wire ddr_cal_fail;

   wire write_edid_clk;
   wire dvi_rx_overflow;

   wire [3:0] debounced_switches;

   wire [31:0] dvi_tx_d_wire;

   wire         VMIR_DVALID;
   wire         VMIR_LOCKED;
   wire         VMIR_HSYNC;
   wire         VMIR_VSYNC;
   wire         VMIR_FIELD;
   wire  [23:0] VMIR_DATA;

   //=======================================================
   //  Structural coding
   //=======================================================

   wire reset_n;
   assign reset_n = CPU_RESET_n;

   // optional DVI input mirroring
   vbvip_mirror vbvip_mirror_inst
   (
       .iCLK           (DVI_RX_CLK),
       .iRST           (!reset_n),

       .iREG_MIRROR    (led_wire[6]),

       .iVIN_DVALID    (DVI_RX_DE),
       .iVIN_LOCKED    (1'b1),
       .iVIN_HSYNC     (DVI_RX_HS),
       .iVIN_VSYNC     (DVI_RX_VS),
       .iVIN_FIELD     (1'b0),
       .iVIN_DATA      (DVI_RX_D),

       .oVOUT_DVALID   (VMIR_DVALID),
       .oVOUT_LOCKED   (VMIR_LOCKED),
       .oVOUT_HSYNC    (VMIR_HSYNC),
       .oVOUT_VSYNC    (VMIR_VSYNC),
       .oVOUT_FIELD    (VMIR_FIELD),
       .oVOUT_DATA     (VMIR_DATA)
   );

   // Qsys module instance
   vblox1 vblox1_inst
     (
      // 1 global signals:
      .clk_50(OSC_50_Bank3),
      .reset_n(reset_n),

      // the_button
      .in_port_to_the_button(BUTTON),

      // the_led
      .out_port_from_the_led(led_wire),

      .slide_switch_export(debounced_switches),

      .oct_rup(RUP_PAD),
      .oct_rdn(RDN_PAD),

`ifndef USE_DDR2_DIMM2
      .memory_mem_a(M1_DDR2_addr),
      .memory_mem_ba(M1_DDR2_ba),
      .memory_mem_cas_n(M1_DDR2_cas_n),
      .memory_mem_cke(M1_DDR2_cke),
      .memory_mem_ck_n(M1_DDR2_clk_n),
      .memory_mem_ck(M1_DDR2_clk),
      .memory_mem_cs_n(M1_DDR2_cs_n),
      .memory_mem_dm(M1_DDR2_dm),
      .memory_mem_dq(M1_DDR2_dq),
      .memory_mem_dqs(M1_DDR2_dqs),
      .memory_mem_dqs_n(M1_DDR2_dqsn),
      .memory_mem_odt(M1_DDR2_odt),
      .memory_mem_ras_n(M1_DDR2_ras_n),
      .memory_mem_we_n(M1_DDR2_we_n),

`else
      .memory_mem_a(M2_DDR2_addr),
      .memory_mem_ba(M2_DDR2_ba),
      .memory_mem_cas_n(M2_DDR2_cas_n),
      .memory_mem_cke(M2_DDR2_cke),
      .memory_mem_ck_n(M2_DDR2_clk_n),
      .memory_mem_ck(M2_DDR2_clk),
      .memory_mem_cs_n(M2_DDR2_cs_n),
      .memory_mem_dm(M2_DDR2_dm),
      .memory_mem_dq(M2_DDR2_dq),
      .memory_mem_dqs(M2_DDR2_dqs),
      .memory_mem_dqs_n(M2_DDR2_dqsn),
      .memory_mem_odt(M2_DDR2_odt),
      .memory_mem_ras_n(M2_DDR2_ras_n),
      .memory_mem_we_n(M2_DDR2_we_n),

`endif

      // Not using the SPD (Serial Presence Detect) I2C EEPROM
`ifndef USE_DDR2_DIMM2
      // .out_port_from_the_ddr2_i2c_scl(M1_DDR2_SCL),
      // .out_port_from_the_ddr2_i2c_sa(M1_DDR2_SA),
      // .bidir_port_to_and_from_the_ddr2_i2c_sda(M1_DDR2_SDA),
`else
      // .out_port_from_the_ddr2_i2c_scl(M2_DDR2_SCL),
      // .out_port_from_the_ddr2_i2c_sa(M2_DDR2_SA),
      // .bidir_port_to_and_from_the_ddr2_i2c_sda(M2_DDR2_SDA),
`endif

      .dvi_tx_pll_areset_conduit_export(1'b0),
      .dvi_tx_clk_clk(dvi_tx_clk_wire),
      .write_edid_clk_clk(write_edid_clk),

      // pll_mem_clk from DDR2 controller is 2x afi_clk, so use as sysclk_2x
      .emif_pll_conduit_pll_mem_clk(ddr_pll_mem_clk), // out
      .sysclk_2x_clk(ddr_pll_mem_clk), // in

      // Connect pll locked output back to dll.
      .emif_pll_conduit_pll_locked(ddr_pll_locked), // out
      .emif_dll_conduit_dll_pll_locked(ddr_pll_locked), // in

      .mem_if_ddr2_emif_0_status_local_init_done(ddr_init_done), // out
      .mem_if_ddr2_emif_0_status_local_cal_success(ddr_cal_success), // out
      .mem_if_ddr2_emif_0_status_local_cal_fail(ddr_cal_fail), // out

      // alt_vip_itc clocked video output.
      // input clock
      .video_out_vid_clk(dvi_tx_clk_wire),
      // outputs
      .video_out_vid_data(dvi_tx_d_wire), // 31:0
      .video_out_underflow(dvi_tx_underflow),
      .video_out_vid_datavalid(DVI_TX_DE),
      .video_out_vid_v_sync(DVI_TX_VS),
      .video_out_vid_h_sync(DVI_TX_HS),
      .video_out_vid_f(),
      .video_out_vid_h(),
      .video_out_vid_v(),

      // alt_vip_cti clocked video input.
      // inputs
      .video_in_vid_clk         (DVI_RX_CLK),
      .video_in_vid_data        (VMIR_DATA), // 23:0
      .video_in_vid_datavalid   (VMIR_DVALID),
      .video_in_vid_locked      (VMIR_LOCKED),
      .video_in_vid_v_sync      (VMIR_VSYNC),
      .video_in_vid_h_sync      (VMIR_HSYNC),
      .video_in_vid_f           (VMIR_FIELD),
      // output
      .video_in_overflow(dvi_rx_overflow),

      // current
      .csense_adc_fo_external_connection_export(CSENSE_ADC_FO),
      .csense_cs_n_external_connection_export(CSENSE_CS_n),
      .csense_sdo_external_connection_export(CSENSE_SDO), // input
      .csense_sdi_external_connection_export(CSENSE_SDI),
      .csense_sck_external_connection_export(CSENSE_SCK),

      // temperature
      .temp_sda_external_connection_export(TEMP_SMDAT), // bidir (inout)
      .temp_scl_external_connection_export(TEMP_SMCLK)
      );

  // Drive these constant if not using.
`ifndef USE_DDR2_DIMM2
  assign M1_DDR2_SCL = 1'b0;
  assign M1_DDR2_SA  = 1'b0;
`else
  assign M2_DDR2_SCL = 1'b0;
  assign M2_DDR2_SA  = 1'b0;
`endif

  assign DVI_TX_CLK = dvi_tx_clk_wire;
  assign DVI_TX_D = dvi_tx_d_wire[23:0];

  //////////////////////////////////////////////////////////////////////
  // DVI TX CONFIG
  // Copied from Terasic's DVI_DEMO_DE4_230_PortA.
  assign DVI_TX_ISEL    = 1'b0; // disable i2c
  assign DVI_TX_SCL     = 1'b1; // SCL/BSEL=1: 24-bit, single-edge input mode
  // EDGE/HTPLG=1: primary latch to occur on the rising edge of the
  // input clock IDCK+
  assign DVI_TX_HTPLG   = 1'b1;
  // SDA/DSEL is don't care when VREF=3.3V (high-swing mode)
  assign DVI_TX_SDA     = 1'b1;
  assign DVI_TX_PD_N    = 1'b1;

  // Undriven outputs:
  // TX_CTL[3:1]
  // TX_DKEN
  // TX_MSEN
  // TX_DDCSCL (inout straight to DVI connector)
  // TX_DDCSDA (inout straight to DVI connector)

  //////////////////////////////////////////////////////////////////////
  // DVI RX

  // Unused inputs:
  // RX_CTL[3:1]
  // RX_SCDT

  // TFP401A DVI RX PHY has OCK_INV tied to ground, so expects signals
  // to be sampled on falling edge of DVI_RX_CLK.
  // alt_vipcti samples the inputs on the posedge of its vid_clk, so just
  // make its vid_clk = ~DVI_RX_CLK.
  // assign dvi_rx_clk_inverted = ~DVI_RX_CLK;
  // Above doesn't work! CTI detects 1921 pixels per line for some reason,
  // plus pixel data has green and red edges.
  // Timing constraints have to be adjusted to account for clock/data skew
  // between RX PHY and FPGA on DE4.
/* -----\/----- EXCLUDED -----\/-----

  always @(posedge DVI_RX_CLK)
    begin
      sampled_DVI_RX_D  <= DVI_RX_D;
      sampled_DVI_RX_DE <= DVI_RX_DE;
      sampled_DVI_RX_HS <= DVI_RX_HS;
      sampled_DVI_RX_VS <= DVI_RX_VS;
    end
 -----/\----- EXCLUDED -----/\----- */

  //////////////////////////////////////////////////////////////////////
  // DVI RX EDID (EEPROM Writing)
  wire  edid_writing;

`define WRITE_EDID_ENABLE 1
`ifdef WRITE_EDID_ENABLE
  write_edid write_edid_0(
    .CLK_I2C_100K(write_edid_clk),
    .EDID_WRITE_TRIGGER(~BUTTON[1]),
    .EDID_WRITING(edid_writing), // output
    .EDID_WP(DVI_EDID_WP),
    .EDID_DDCSCL(DVI_RX_DDCSCL),
    .EDID_DDCSDA(DVI_RX_DDCSDA)
  );

  // edid-writing: led indication
  // Blink LED[7] while writing to EEPROM.
  reg        edid_writing_led;
  reg [12:0] edid_led_cnt;

  always @(posedge write_edid_clk)
  begin
    if (edid_writing)
      begin
        if (edid_led_cnt == 0)
            edid_writing_led <= ~edid_writing_led;
        edid_led_cnt <= edid_led_cnt + 1'b1;
      end
    else
      begin
        edid_writing_led <= 1'b0;
        edid_led_cnt <= 0;
      end
  end

`else
  // !defined(WRITE_EDID_ENABLE)

  wire edid_writing_led;

  assign edid_writing = 1'b0;
  assign edid_writing_led = 1'b0;
  assign DVI_EDID_WP = 1'b1;
  assign DVI_RX_DDCSCL = 1'bz;
  assign DVI_RX_DDCSDA = 1'bz;

`endif // WRITE_EDID_ENABLE

  //////////////////////////////////////////////////////////////////////
  // HSMC_SCL output & HSMC_SDA inout left undriven...

  //////////////////////////////////////////////////////////////////////

  assign LED = ~{edid_writing_led,  // 7
                 led_wire[6:5],
                 ddr_cal_fail,      // 4
                 ddr_cal_success,   // 3
                 ddr_init_done,     // 2
                 dvi_rx_overflow,   // 1
                 dvi_tx_underflow}; // 0

  //////////////////////////////////////////////////////////////////////
  generate
    genvar i;

    for (i = 0; i < 4; i = i+1)
      begin : gen_debounce
        debounce debounce_inst
             (.clk(OSC_50_Bank3),
              .button(SLIDE_SW[i]),
              .result(debounced_switches[i])
              );
      end
  endgenerate

endmodule
